<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zach's Second Brain</title>

  <!-- Modern Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

  <!-- Core Styles -->
  <link rel="stylesheet" href="style.css">

  <!-- Marked.js for Markdown Rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>

<body>
  <button id="do-nothing-btn" onclick="breakSite()">ABORT</button>

  <!-- Navigation / File List Sidebar -->
  <nav id="sidebar">
    <div class="sidebar-header">
      <h1>My Stuff</h1>
      <input type="text" id="search" placeholder="Search notes..." onkeyup="filterFiles()">
    </div>

    <div id="list-container">
      <div id="list">
        <!-- Files will be injected here -->
      </div>
    </div>
  </nav>

  <!-- Main Note Reading Area -->
  <main id="main-content">
    <div id="content-viewer">
      <div class="empty-state">
        <h2>uh this all my stuff so far</h2>
        <p>can look at all da stuff on the left</p>
      </div>
    </div>
  </main>

  <script>
    // Configuration
    const REPO_API_URL = 'https://api.github.com/repos/zickedy/zickedy/contents';
    const RAW_BASE_URL = 'https://raw.githubusercontent.com/zickedy/zickedy/main/';

    async function init() {
      const list = document.getElementById('list');
      list.innerHTML = '<div style="padding: 1rem; color: #8b949e;">Loading ecosystem...</div>';

      try {
        const res = await fetch(REPO_API_URL);
        if (!res.ok) throw new Error(res.status);

        const currentFiles = await res.json();
        renderSidebar(currentFiles);

      } catch (e) {
        list.innerHTML = `<div style="padding: 1rem; color: #f85149;">Error connecting to Hub: ${e.message}</div>`;
      }
    }

    function renderSidebar(files) {
      const list = document.getElementById('list');
      list.innerHTML = '';

      const fileNodes = files.filter(f => f.type === 'file');

      if (fileNodes.length === 0) {
        list.innerHTML = '<div style="padding: 1rem; color: #8b949e;">No notes found.</div>';
        return;
      }

      fileNodes.forEach(f => {
        const a = document.createElement('a');

        // Clean up display names (remove extension for .md files for cleaner look)
        let displayName = f.name;
        if (displayName.endsWith('.md')) {
          displayName = displayName.replace('.md', '');
        }

        const strong = document.createElement('strong');
        strong.textContent = displayName;
        a.appendChild(strong);
        a.dataset.name = f.name; // Keep original name for search

        // Handle clicking a file
        a.onclick = (e) => {
          e.preventDefault();

          // UI State updates
          document.querySelectorAll('#list a').forEach(el => el.classList.remove('active'));
          a.classList.add('active');

          // Load Content
          loadContent(f);
        };

        list.appendChild(a);
      });
    }

    async function loadContent(fileData) {
      const viewer = document.getElementById('content-viewer');
      viewer.innerHTML = '<div class="empty-state">Loading node...</div>';

      try {
        // Fetch raw content
        const res = await fetch(fileData.download_url);
        if (!res.ok) throw new Error("Failed to load content.");

        const rawContent = await res.text();

        // If it's a markdown file, parse it. Otherwise, put it in a pre block.
        if (fileData.name.endsWith('.md')) {
          viewer.innerHTML = `<div class="markdown-body">${marked.parse(rawContent)}</div>`;
        } else if (fileData.name.endsWith('.html') || fileData.name.endsWith('.css') || fileData.name.endsWith('.js')) {
          // Escape HTML for code files so they show as text, not raw rendered HTML by accident
          const escaped = rawContent.replace(/</g, "&lt;").replace(/>/g, "&gt;");
          viewer.innerHTML = `<pre><code>${escaped}</code></pre>`;
        } else {
          // General fallback
          const pre = document.createElement('pre');
          const code = document.createElement('code');
          code.textContent = rawContent;
          pre.appendChild(code);
          viewer.innerHTML = '';
          viewer.appendChild(pre);
        }

      } catch (error) {
        viewer.innerHTML = `<div class="empty-state" style="color:#f85149;"><h2>Error linking node</h2><p>${error.message}</p></div>`;
      }
    }

    function filterFiles() {
      const val = document.getElementById('search').value.toLowerCase();
      const items = document.querySelectorAll('#list a');

      items.forEach(item => {
        // Search against the original filename stored in dataset
        const itemName = item.dataset.name.toLowerCase();
        item.style.display = itemName.includes(val) ? 'block' : 'none';
      });
    }

    function breakSite() {
      // 1. Give every major element its own chaotic animation (including the button)
      const allElements = document.querySelectorAll('div, nav, main, h1, h2, p, a, input, pre, code, button');
      const animations = ['chaotic-spin', 'chaotic-shake', 'chaotic-pulse', 'chaotic-float'];

      allElements.forEach(el => {
        const anim = animations[Math.floor(Math.random() * animations.length)];
        const duration = 1 + Math.random() * 4;
        const delay = Math.random() * 2;

        el.style.animation = `${anim} ${duration}s infinite alternate`;
        el.style.animationDelay = `${delay}s`;
        el.style.transformOrigin = `${Math.random() * 100}% ${Math.random() * 100}%`;
      });

      // 2. Continually mess with background colors of individual elements
      setInterval(() => {
        allElements.forEach(el => {
          if (Math.random() > 0.9) {
            el.style.backgroundColor = `hsla(${Math.random() * 360}, 100%, 50%, 0.3)`;
            el.style.color = `hsla(${Math.random() * 360}, 100%, 50%, 1)`;
          }
        });
      }, 400);

      // 3. Make individual letters fall
      const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null, false);
      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        if (node.nodeValue.trim() !== '' &&
          node.parentElement.tagName !== 'SCRIPT' &&
          node.parentElement.tagName !== 'STYLE' &&
          node.parentElement.id !== 'do-nothing-btn') {
          textNodes.push(node);
        }
      }

      textNodes.forEach(textNode => {
        const text = textNode.nodeValue;
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < text.length; i++) {
          if (text[i].trim() === '') {
            fragment.appendChild(document.createTextNode(text[i])); // preserve spaces/newlines
          } else {
            const span = document.createElement('span');
            span.textContent = text[i];
            span.className = 'falling-letter';
            span.style.animationDelay = `${Math.random() * 3}s`;
            fragment.appendChild(span);
          }
        }
        textNode.parentNode.replaceChild(fragment, textNode);
      });
    }

    // Boot the app
    document.addEventListener('DOMContentLoaded', init);
  </script>

</body>

</html>